/*
Copyright (C) 2001-2008, The Perl Foundation.
$Id: tcllist.pmc 29952 2008-08-02 22:45:13Z allison $

=head1 NAME

pmc/tcllist.pmc - Tcl List

=head1 DESCRIPTION

These are the vtable functions for the TclList base class

=head2 Methods

=over 4

=cut

*/

#include "parrot/embed.h"

/* cache of classes referenced */

pmclass TclList
    dynpmc
    need_ext
    extends ResizablePMCArray
    provides    array
    group   tcl_group
    hll     Tcl
    maps    Array
    maps    ResizablePMCArray
{

/*

=item C<STRING *get_string()>

Returns the list as a string

=cut

*/

    VTABLE STRING* get_string() {
        STRING *retval  = string_from_literal(INTERP, "");
        STRING *replace = CONST_STRING(INTERP, "replace");
        INTVAL  elems   = VTABLE_get_integer(INTERP, SELF);
        INTVAL  i;
        STRING *orig, *repl;
        PMC    *P0;
        INTVAL  count, pos, brace_check_pos, has_braces;

        for (i = 0; i < elems; i++) {
            STRING *str    = VTABLE_get_string_keyed_int(INTERP, SELF, i);
            INTVAL str_len = string_length(INTERP, str);

            if (str_len == 0) {
                /* empty element */
                str = CONST_STRING(INTERP, "{}");
                goto append_elem;
            }

            count = pos = brace_check_pos = has_braces = 0;
            while (pos < str_len) {
                switch (string_ord(INTERP, str, pos)) {
                    case '{':
                        count++;
                        has_braces = 1;
                        break;
                    case '}':
                        if (--count < 0) goto escape;
                        brace_check_pos = pos;
                        break;
                    default:
                        break;
                }
                pos++;
            }

            if (count != 0) goto escape;
            if (has_braces && count == 0 && brace_check_pos != str_len -1) {

                /* escape {ab}\, but brace-wrap anything else. */
                if (brace_check_pos == str_len - 2 && 
                    string_ord(INTERP, str, str_len-1) == '\\')
                    goto escape;
                else
                    goto quote;
            }
       
            /* trailing slash */
            if (str_len-1 == string_str_index(INTERP, str, CONST_STRING(INTERP, "\\"), str_len-1))
                goto escape;


            if (-1 != string_str_index(INTERP,  str, CONST_STRING(INTERP, "\""), 0))
                 goto quote;

            if (-1 != string_str_index(INTERP,  str, CONST_STRING(INTERP, "["), 0))
                 goto quote;

            /* only check hashes on first elem.*/
            if (i == 0 && -1 != string_str_index(INTERP, str, CONST_STRING(INTERP, "#"), 0))
                goto quote;

            if (-1 != string_str_index(INTERP, str, CONST_STRING(INTERP, "$"), 0))
                goto quote;

            if (-1 != string_str_index(INTERP, str, CONST_STRING(INTERP, ";"), 0))
                goto quote;

            /* \'d constructs */
            if (-1 != string_str_index(INTERP, str, CONST_STRING(INTERP, "]"), 0))
                goto escape;

            if (-1 != string_str_index(INTERP, str, CONST_STRING(INTERP, "\\"), 0))
                goto escape;

            /* {}'d constructs */
            if (str_len != CHARSET_FIND_CCLASS(INTERP, enum_cclass_whitespace, str, 0, str_len))
                goto quote;

            goto append_elem;

          escape:
            P0 = pmc_new(INTERP, enum_class_String);
            VTABLE_set_string_native(INTERP, P0, str);

            orig = CONST_STRING(INTERP, "\\");
            repl = CONST_STRING(INTERP, "\\\\");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "\t");
            repl = CONST_STRING(INTERP, "\\t");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "\f");
            repl = CONST_STRING(INTERP, "\\f");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "\n");
            repl = CONST_STRING(INTERP, "\\n");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "\r");
            repl = CONST_STRING(INTERP, "\\r");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "\v");
            repl = CONST_STRING(INTERP, "\\v");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, ";");
            repl = CONST_STRING(INTERP, "\\;");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "$");
            repl = CONST_STRING(INTERP, "\\$");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "}");
            repl = CONST_STRING(INTERP, "\\}");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "{");
            repl = CONST_STRING(INTERP, "\\{");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, " ");
            repl = CONST_STRING(INTERP, "\\ ");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "[");
            repl = CONST_STRING(INTERP, "\\[");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "]");
            repl = CONST_STRING(INTERP, "\\]");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            orig = CONST_STRING(INTERP, "\"");
            repl = CONST_STRING(INTERP, "\\\"");
            Parrot_PCCINVOKE(INTERP, P0, replace, "SS->", orig, repl);

            str = VTABLE_get_string(INTERP, P0);
            goto append_elem;

          quote:
            str = string_append(INTERP, CONST_STRING(INTERP, "{"), str);
            str = string_append(INTERP, str, CONST_STRING(INTERP, "}"));

          append_elem:
            retval = string_append(INTERP, retval, str);
            retval = string_append(INTERP, retval, CONST_STRING(INTERP, " "));
        }

        /* remove the extra space at the end, if necessary*/
        if (string_length(INTERP, retval))
            string_chopn_inplace(INTERP, retval, 1);

        return retval;
    }

/*

=item C<void set_pmc(PMC *other)>

An alias to assign_pmc to make other things happy before set_pmc is removed.

=cut

*/

    void set_pmc(PMC *other) {
        VTABLE_assign_pmc(INTERP, SELF, other);
    }

/*

=item C<void assign_pmc(PMC *other)>

Copy the contents of other to self.

=cut

*/

    void assign_pmc(PMC *other) {
        STRING *array  = CONST_STRING(INTERP, "array");
        STRING *string = CONST_STRING(INTERP, "String");
        STRING *undef  = CONST_STRING(INTERP, "Undef");

        if (VTABLE_does(INTERP, other, array))
        {
            INTVAL size;
            INTVAL i;

            size = VTABLE_elements(INTERP, other);
            SELF.set_integer_native(size);
            for (i = 0; i < size; i++) {
                PMC* elem = VTABLE_get_pmc_keyed_int(INTERP, other, i);
                SELF.set_pmc_keyed_int(i, elem);
            }
        }
        else if (VTABLE_isa(INTERP, other, string))
        {
            STRING *v = VTABLE_get_string(INTERP, other);
            pmc_reuse(INTERP, SELF, other->vtable->base_type, 0);
            SELF.set_string_native(v);
        }
        else if (VTABLE_isa(INTERP, other, undef))
        {
            pmc_reuse(INTERP, SELF, other->vtable->base_type, 0);
        }
        else
            Parrot_ex_throw_from_c_args(INTERP, NULL, EXCEPTION_INVALID_OPERATION,
                "unable to assign self to TclList");
    }

/*

=item METHOD reverse

Reverse ourselves.

This algorithm is very generic and could easily be
moved back into parrot core where we'd be happy to inherit it.

=cut

*/

    METHOD reverse() {
        INTVAL low  = 0;
        INTVAL high = SELF.get_integer() - 1;
        PMC*  swap;

        while (low < high) {
            swap = SELF.get_pmc_keyed_int(high);
            SELF.set_pmc_keyed_int(high, SELF.get_pmc_keyed_int(low)) ;
            SELF.set_pmc_keyed_int(low, swap);

            low++;
            high--;
        }

        RETURN(PMC *SELF);
    }

/*

=back

*/

}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
