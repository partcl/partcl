/*
 *  Copyright (C) 2001-2008, The Perl Foundation.
 *  $Id: tclstring.pmc 31435 2008-09-26 11:49:50Z jkeenan $
 */

#include "parrot/embed.h"
#include "parrot/cclass.h"
#include <stdio.h>

pmclass TclString
    dynpmc
    extends String
    does    string
    group   tcl_group
    hll     Tcl
    maps    String
{

    METHOD get_list(STRING* str :optional) {
        PMC*    retval = pmc_new(INTERP, pmc_type(INTERP, CONST_STRING(INTERP, "TclList")));
        INTVAL  pos = -1;       /* we increment before we use it */
        INTVAL  len;            /* length of the string */
        INTVAL  character;      /* which character we're testing */
        STRING* element_string; /* string chunk to add to the list */
        INTVAL  element_length; /* size of chunk to add to list */
        PMC*    element_pmc;    /* An item to add to the list */
        INTVAL  peek_pos;       /* keep track of pos when scanning ahead */
        INTVAL  depth;          /* keep track of nested {} pairs */

        if (! str)
             str = SELF.get_string();

        /* make sure our return value isn't GC'd out from under us! */
        Parrot_register_pmc(INTERP, retval);

        len = string_length(INTERP, str);

      eat_space:
        while (Parrot_string_is_cclass(INTERP, enum_cclass_whitespace, str, ++pos));

      loop:
        if (pos >= len) goto done;

        character = string_ord(INTERP, str, pos);
        if (character == '{') {
            depth = 1;
            peek_pos = pos;
          find_close_bracket:
            peek_pos++;
            if (peek_pos >= len) {
                Parrot_unregister_pmc(INTERP, retval);
                Parrot_ex_throw_from_c_args(INTERP, NULL, CONTROL_ERROR,
                    "unmatched open brace in list");
            }

            character = string_ord(INTERP, str, peek_pos);
            if (character == '{') {
                depth++;
                goto find_close_bracket;
            }
            else if (character == '}')  {
                if (--depth) goto find_close_bracket;

                if (peek_pos + 1 >= len) goto found_close_bracket;
                if (!Parrot_string_is_cclass(INTERP, enum_cclass_whitespace, str, peek_pos + 1)) {
                    STRING* follows_brace;
                    INTVAL  chunk_length;
                    INTVAL  ws_pos;
                    peek_pos++;
                    ws_pos = CHARSET_FIND_CCLASS(INTERP,
                        enum_cclass_whitespace, str, peek_pos, len-peek_pos);
                    chunk_length = ws_pos - peek_pos;
                    follows_brace = string_substr(INTERP, str, peek_pos,
                        chunk_length, &follows_brace, 0);

                    Parrot_unregister_pmc(INTERP, retval);
                    Parrot_ex_throw_from_c_args(INTERP, NULL, CONTROL_ERROR,
                            "list element in braces followed by \"%s\" instead of space",
                            string_to_cstring(INTERP, follows_brace));
                }

              found_close_bracket:
                element_length = peek_pos - pos++ - 1;
                element_string = string_substr(INTERP, str, pos,
                    element_length, &element_string, 0);
                pos = pos + element_length + 1;

                /* Now add that list as another element*/
                VTABLE_push_string(INTERP, retval, element_string);
                goto eat_space;
            }
            else if (character == '\\') {
                peek_pos++;
                goto find_close_bracket;
            }
            else
              goto find_close_bracket;
            }
        else if (character == '"') {
            /* find the closing '"'*/
            peek_pos = ++pos;
          quote_loop:
            if (peek_pos >= len) {
                Parrot_unregister_pmc(INTERP, retval);
                Parrot_ex_throw_from_c_args(INTERP, NULL, CONTROL_ERROR,
                    "unmatched open quote in list");
            }
            character = string_ord(INTERP, str, peek_pos);
            if (character == '\\') {
                peek_pos += 2;
                goto quote_loop;
            }
            else if (character == '"') goto found_quote;
            peek_pos++;
            goto quote_loop;
        }
        peek_pos = pos;

        while (peek_pos < len) {
            if ('\\' == string_ord(INTERP, str, peek_pos)) {
                peek_pos += 2;
                continue;
            }
            if (Parrot_string_is_cclass(INTERP, enum_cclass_whitespace, str, peek_pos))
                break;

            peek_pos++;
        }

      extract:
        /*  extract the element */
        element_length = peek_pos - pos;
        element_string = string_substr(INTERP, str, pos, element_length, &element_string, 0);

        /* add it to the list*/
        element_pmc = pmc_new(INTERP, pmc_type(INTERP, CONST_STRING(INTERP, "TclConst")));
        VTABLE_set_string_native(INTERP, element_pmc, element_string);
        VTABLE_push_pmc(INTERP, retval, element_pmc);

        /* find the next pos */
        pos = peek_pos;
        goto eat_space;

      found_quote:
        if (peek_pos + 1 >= len)
            goto found_close_quote;

        if (!Parrot_string_is_cclass(INTERP, enum_cclass_whitespace, str, peek_pos+1)) {
            STRING* follows_quote;
            INTVAL  chunk_length;
            INTVAL  ws_pos;
            peek_pos++;
            ws_pos = CHARSET_FIND_CCLASS(INTERP, enum_cclass_whitespace, str,
                peek_pos, len - peek_pos);
            chunk_length = ws_pos - peek_pos;
            follows_quote = string_substr(INTERP, str, peek_pos, chunk_length, &follows_quote, 0);
            Parrot_unregister_pmc(INTERP, retval);
            Parrot_ex_throw_from_c_args(INTERP, NULL, CONTROL_ERROR,
                    "list element in quotes followed by \"%s\" instead of space",
                    string_to_cstring(INTERP, follows_quote));
        }

     found_close_quote:
        element_length = peek_pos - pos;
        element_string = string_substr(INTERP, str, pos, element_length, &element_string, 0);

        element_pmc = pmc_new(INTERP, pmc_type(INTERP, CONST_STRING(INTERP, "TclConst")));
        VTABLE_set_string_native(INTERP, element_pmc, element_string);
        VTABLE_push_pmc(INTERP, retval, element_pmc);

        pos = peek_pos + 1;
        goto eat_space;

      done:
        Parrot_unregister_pmc(INTERP, retval);
        RETURN(PMC *retval);
    }
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
